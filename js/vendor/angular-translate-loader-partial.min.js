/*!
 * angular-translate - v2.11.0 - 2016-03-20
 * 
 * Copyright (c) 2016 The angular-translate team, Pascal Precht; Licensed MIT
 */
!function(t,e){"function"==typeof define&&define.amd?define([],function(){return e()}):"object"==typeof exports?module.exports=e():e()}(this,function(){function t(){"use strict";function t(t,e){this.name=t,this.isActive=!0,this.tables={},this.priority=e||0}function e(t){return Object.prototype.hasOwnProperty.call(o,t)}function r(t){return angular.isString(t)&&""!==t}function a(t){if(!r(t))throw new TypeError("Invalid type of a first argument, a non-empty string expected.");return e(t)&&o[t].isActive}function n(t,e){for(var r in e)e[r]&&e[r].constructor&&e[r].constructor===Object?(t[r]=t[r]||{},n(t[r],e[r])):t[r]=e[r];return t}function i(){var t=[];for(var e in o)o[e].isActive&&t.push(o[e]);return t.sort(function(t,e){return t.priority-e.priority}),t}t.prototype.parseUrl=function(t,e){return angular.isFunction(t)?t(this.name,e):t.replace(/\{part\}/g,this.name).replace(/\{lang\}/g,e)},t.prototype.getTable=function(t,e,r,a,n,i){if(this.tables[t])return e.when(this.tables[t]);var o=this;return r(angular.extend({method:"GET",url:this.parseUrl(n,t)},a)).then(function(e){return o.tables[t]=e.data,e.data},function(){return i?i(o.name,t).then(function(e){return o.tables[t]=e,e},function(){return e.reject(o.name)}):e.reject(o.name)})};var o={};this.addPart=function(a,n){if(!r(a))throw new TypeError("Couldn't add part, part name has to be a string!");return e(a)||(o[a]=new t(a,n)),o[a].isActive=!0,this},this.setPart=function(a,n,i){if(!r(a))throw new TypeError("Couldn't set part.`lang` parameter has to be a string!");if(!r(n))throw new TypeError("Couldn't set part.`part` parameter has to be a string!");if("object"!=typeof i||null===i)throw new TypeError("Couldn't set part. `table` parameter has to be an object!");return e(n)||(o[n]=new t(n),o[n].isActive=!1),o[n].tables[a]=i,this},this.deletePart=function(t){if(!r(t))throw new TypeError("Couldn't delete part, first arg has to be string.");return e(t)&&(o[t].isActive=!1),this},this.isPartAvailable=a,this.$get=["$rootScope","$injector","$q","$http",function(u,s,l,c){var f=function(t){if(!r(t.key))throw new TypeError("Unable to load data, a key is not a non-empty string.");if(!r(t.urlTemplate)&&!angular.isFunction(t.urlTemplate))throw new TypeError("Unable to load data, a urlTemplate is not a non-empty string or not a function.");var e=t.loadFailureHandler;if(void 0!==e){if(!angular.isString(e))throw new Error("Unable to load data, a loadFailureHandler is not a string.");e=s.get(e)}var a=[],o=i();return angular.forEach(o,function(r){a.push(r.getTable(t.key,l,c,t.$http,t.urlTemplate,e)),r.urlTemplate=t.urlTemplate}),l.all(a).then(function(){var e={};return o=i(),angular.forEach(o,function(r){n(e,r.tables[t.key])}),e},function(){return l.reject(t.key)})};return f.addPart=function(a,n){if(!r(a))throw new TypeError("Couldn't add part, first arg has to be a string");return e(a)?o[a].isActive||(o[a].isActive=!0,u.$emit("$translatePartialLoaderStructureChanged",a)):(o[a]=new t(a,n),u.$emit("$translatePartialLoaderStructureChanged",a)),f},f.deletePart=function(t,a){if(!r(t))throw new TypeError("Couldn't delete part, first arg has to be string");if(void 0===a)a=!1;else if("boolean"!=typeof a)throw new TypeError("Invalid type of a second argument, a boolean expected.");if(e(t)){var n=o[t].isActive;if(a){var i=s.get("$translate"),l=i.loaderCache();"string"==typeof l&&(l=s.get(l)),"object"==typeof l&&angular.forEach(o[t].tables,function(e,r){l.remove(o[t].parseUrl(o[t].urlTemplate,r))}),delete o[t]}else o[t].isActive=!1;n&&u.$emit("$translatePartialLoaderStructureChanged",t)}return f},f.isPartLoaded=function(t,e){return angular.isDefined(o[t])&&angular.isDefined(o[t].tables[e])},f.getRegisteredParts=function(){var t=[];return angular.forEach(o,function(e){e.isActive&&t.push(e.name)}),t},f.isPartAvailable=a,f}]}return angular.module("pascalprecht.translate").provider("$translatePartialLoader",t),t.displayName="$translatePartialLoader","pascalprecht.translate"});